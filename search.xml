<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java数据结构线性表——顺序表的设计思想及实现]]></title>
    <url>%2F2018%2F04%2F25%2F%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[线性表抽象数据类型概述 什么是抽象数据类型这里引用一段相关描述： 我们都知道java在默认情况下，所有的基本数据类型(int,float,boolean等)都支持基本运算，如加减法，这是因为系统已帮我们实现了这些基本数据类型的的基本运算。而对于自定义的数据类型(如类)也需要定义相应的运算，但在实际使用这些自定义的数据类型的运算时需要自己实现相关的运算，也就是说用户自定义的数据类型的运算需要我们自己利用系统提供的基本运算来定义和实现。这些自定义了数据结构(如自定义类)和包含相关运算组合实现的数据类型就称其为抽象数据类型(ADT,Abstract Data Type),因此一个ADT会包含数据声明和运算声明。常用的ADT包含链表、栈、队列、优先队列、二叉树、散列表、图等，所以接下来我们要分析的顺序表和链表也属于ADT范畴. Java数据结构中对线性表的定义: 线性表是由n(n&gt;=0)个类型相同的数据元素a0,a1,…,an-1组成的有限的序列，在数学中记作(a0,a1,…,an-1)，其中ai的数据类型可以是基本数据类型(int,float等)、字符或类。n代表线性表的元素个数，也称其为长度(Length)。若n=0，则为空表；若n &gt; 0，则ai(0 &lt; i &lt; n-1)有且仅有一个前驱(Predecessor)元素ai-1和一个后继(Successor)元素ai+1，a0没有前驱元素，ai没有后继元素。 以上，便是关于线性表抽象数据类型的概述。 线性表的顺序存储设计和实现（顺序表） 顺序储存结构的设计原理 顺序存储结构底层是利用数组来实现的，而数组可以存储具有相同数据类型的元素集合，如int，float或者自定义类型等，当我们创建一个数组时，计算机操作系统会为该数组分配一块连续的内存块，这也就意味着数组中的每个存储单元的地址都是连续的，因此只要知道了数组的起始内存地址就可以通过简单的乘法和加法计算出数组中第n-1个存储单元的内存地址. 通过上图可以发现为了访问一个数组元素，该元素的内存地址需要计算其距离数组基地址的偏移量，即用一个乘法计算偏移量然后加上基地址，就可以获得数组中某个元素的内存地址。其中c代表的是元素数据类型的存储空间大小，而序号则为数组的下标索引。整个过程需要一次乘法和一次加法运算，因为这两个操作的执行时间是常数时间，所以我们可以认为数组访问操作能再常数时间内完成，即时间复杂度为O(1)，这种存取任何一个元素的时间复杂度为O(1)的数据结构称之为随机存取结构。 及a1=a0+c,a2=a1+c,a3=a2+cc代表每个数组元素所占存储空间的大小。因为顺序表是一段连续不断的空间里储存的，所以我们只需要用前一个数组元素的存储位置加上其所占的存储空间大小，就可以得出当前数组元素的存储位置，只需要进行简单的加法和乘法运算就可以实现对顺序表中的元素进行基本的插入，删除，查找操作了。 这里引用一下顺序表的定义： 线性表的顺序存储结构称之为顺序表(Sequential List),它使用一维数组依次存放从a0到an-1的数据元素(a0,a1,…,an-1)，将ai(0&lt; i &lt;&gt; n-1)存放在数组的第i个元素，使得ai与其前驱ai-1及后继ai+1的存储位置相邻，因此数据元素在内存的物理存储次序反映了线性表数据元素之间的逻辑次序。 顺序储存结构的实现下面我们分析一下顺序表的实现，前面说了线性表的抽象数据类型的性质，所以我们这里首先要创建一个顺序表接口类用来声明顺序表的各种操作方法。关于接口这里引用Java数据结构中的一段描述： java语言的接口是一组抽象方法，常量和内嵌型的集合。接口是多继承的，一个接口可以继承多个父接口，接口是一种数据类型，采用抽象的形式来约定，因此接口只有被类实现之后才有意义。一个接口可被多个类实现，接口提供方法声明与方法实现是相分离的机制。使实现接口的多个类表现出共同的行为能力，接口声明的抽象方法在实现接口的多个类中表现出多态性。 声明接口类 1234567891011121314151617181920212223242526272829303132333435 /** * 首先声明一个顺序表的接口类&lt;List&gt;,并实现该接口。 * 泛型参数T表示数据源数的数据类型 * 定义线性表ADT的基本操作 * * @author MaYaP * */public interface List&lt;T&gt; &#123; boolean isEmpty(); //判断集合是否为空 int length(); //返回线性表的元素个数(长度) T get(int i); // 返回第i个元素 void set(int i, T x); //设置第i个元素的值为x int insert(int i, T x); //插入x作为第i个元素 void append(T x); //在线性表最后插入x元素 T remove (int i); //删除第i个元素并返回被删除的对象 void removeAll(); //删除线性表内所有元素 T search(T key); //查找，返回首次出现的关键字为key元素,按内容查找 boolean contain(T x); //判断集合是否包含元素x,及元素x是否属于集合 void showListInfo(); //显示表长和表内的所有元素 &#125; 其次，在声明好了接口类后，我们需要对其中声明的方法进行实现，所以接下来我们需要声明一个实现接口方法的类。用来实现接口类中的各种方法。 声明一个实现接口类方法的类SeqList。及实现接口类各种方法的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220 /** * 声明一个实现接口类方法的类SeqList。及实现接口类各种方法的代码。 * @author MaYaP * * @param &lt;T&gt; */public class SeqList&lt;T&gt; implements List&lt;T&gt; &#123; protected Object[] element; //对象数组存储顺序表的数据类型，保护成员 protected int n; //顺序表的元素个数 /** * 构建容量为length的空表 * @param length */ public SeqList(int length) &#123; this.element = new Object[length]; // 申请数组的存储空间，元素为null,若数组长度小于0，则抛出负数组异常。 this.n=0; &#125; /** *创建默认容量的空表。 */ public SeqList()&#123; this(64); //调用本类已声明的指定参数列表的构建方法 &#125; /** * 判断顺序表是否为空，若为空则返回ture */ @Override public boolean isEmpty() &#123; // TODO Auto-generated method stub return this.n==0; //双等于判断，单等于是赋值。 &#125; /** * 返回顺序表元素个数，长度。 */ @Override public int length() &#123; // TODO Auto-generated method stub return this.n; &#125;/** * 按序号查找，返回第i个元素，0&lt;i&lt;n.若i越界，则返回null */ @Override public T get(int i) &#123; if(i&gt;=0 &amp;&amp; i&lt;this.n) &#123; int p=i; //return (T)this.element[i]; System.out.println(&quot;position=&quot;+p+&quot;,is:&quot;+this.element[i]);//返回第i个元素 &#125; return null; // TODO Auto-generated method stub &#125; /** * 设置第i个元素为x，0&lt;i&lt;n,若i越界，则抛出序号越界异常，若i=null，则抛出空对象异常。 */ @Override public void set(int i, T x) &#123; // TODO Auto-generated method stub if(x==null) throw new NullPointerException(&quot;x==null&quot;);//抛出空对象异常 if(i&gt;=0 &amp;&amp; i&lt;n) this.element[i]=x; else throw new java.lang.IndexOutOfBoundsException(i+&quot;&quot;);//抛出序号越界异常 &#125; /** * 插入x做为第i个元素，x!=null，返回x序号，若x==null,则抛出空对象异常 * 对序号i采取容错措施，若i&lt;0,则在表头插入x，若i&gt;n,则在表尾插入x。 */ @Override public int insert(int i, T x) &#123; // TODO Auto-generated method stub if(x==null) throw new NullPointerException(&quot;x==null&quot;); // 抛出空对象异常 if(i&lt;0) i=0; //插入在表头 if(i&gt;this.n) i=this.n; //插入在最后 Object[] source=this.element; // 数组引用赋值，source也引用element if(this.n==element.length) // 如果数组满了，则扩充顺序表的数据容量 &#123; this.element=new Object[source.length*2]; //重新申请一个容量更大的数组 for(int j=0;j&lt;i;j++) //复制当前数组前i-1个元素 this.element[j]=source[j]; &#125; for(int j=this.n-1;j&gt;=i;j--) //从i开始至表尾的元素向后移动 this.element[j]=source[j]; this.element[i]=x; this.n++; System.out.println(&quot;insert a new node:&quot;+this.element[i].toString()+&quot;,in position=&quot;+i); //输出插入元素信息 return i++; //返回x序号 &#125; /** * 在线性表尾插入x */ @Override public void append(T x) &#123; // TODO Auto-generated method stub &#125;/** * 删除第i个元素，0=&lt;i&lt;0,返回被删除元素，若i越界，则返回 null */ @Override public T remove(int i) &#123; // TODO Auto-generated method stub if(this.n==0 || i&lt;0 || i&gt;this.n ) &#123; // throw new IndexOutOfBoundsException(i + &quot;&quot;); // 抛出序号越界异常 return null; &#125; T old = (T)this.element[i]; //old 中存储被删除元素 System.out.println(&quot;node:&quot;+this.element[i].toString()+&quot;,is Delete from the SeqList&quot;);//输出删除信息 for (int j=i;j&lt;this.n-1;j++) &#123; this.element[j]=this.element[j+1]; //元素前移一个位置 &#125; this.element[this.n-1]=null; //设置数组元素对象为空，释放原引用实例 this.n--; return old; //返回old局部变量引用的对象，传递对象引用 &#125;/** * 删除所有元素 */ @Override public void removeAll() &#123; // TODO Auto-generated method stub this.n=0; //设置长度为0，未释放数组空间 &#125; /** * 判断集合是否包含元素x，即元素x是否属于集合 */ @Override public boolean contain(T x) &#123; // TODO Auto-generated method stub return false; &#125;/** * 显示表长和表内所有数据元素 */ @Override public void showListInfo() &#123; // TODO Auto-generated method stub //int i=this.length(); /** * 使用for循环遍历顺序表，输出表内全部内容 */ /*for(int i=0;i&lt;this.length();i++) &#123; int p=i; //重新定义一个整型变量p来记录元素下标，以便输出 System.out.println(&quot;insert a new node:&quot;+this.element[i]+&quot;,in position=&quot;+p); //输出顺序表内所有插入的元素及其对应的下标序号。 &#125;*/ System.out.println(&quot;seqlist len=&quot;+this.length());//输出顺序表的长度length(). /** * 通过for循环，以（，，，，）的形式输出所有顺序表内的元素。 */ System.out.print(&quot;The seqlist is:(&quot;);//打印括号 /** * for循环，遍历整个顺序表，并输出其中元素。 */ for(int i=0;i&lt;this.length();i++)&#123; System.out.print(this.element[i]+&quot;,&quot;); &#125; System.out.println(&quot;)&quot;);//输出反括号 &#125;/* * 按内容查找 */ @Override public T search(T key) &#123; // TODO Auto-generated method stub return null; &#125;&#125; 其中，关于顺序表的插入，删除，查找，就不在做详细描述了，代码注释都比较详细。 当然，在声明了实现接口的类并且实现了其中的构造方法后。我们需要创建main主函数类来测试实现一下我们的顺序表的构造是否成功。 声明main主函数类测试实现接口和接口实现类123456789101112131415161718192021222324252627282930313233 /* * 声明main主函数类测试实现&lt;List&gt;接口和接口实现类&lt;SeqList&gt; */public class Main &#123; public static void main(String args[])&#123; //创建顺序表 SeqList&lt;Integer&gt; list1 =new SeqList&lt;Integer&gt;();//空表 //建表，插入新的数据元素 System.out.println(&quot;建表操作：&quot;); list1.insert(1, 1); //相当于执行了四次插入操作 list1.insert(2, 2); list1.insert(3, 3); list1.insert(4, 4); list1.showListInfo(); //调用方法，显示表的长度和表内所有的内容 //查找操作 System.out.println(&quot;查找操作：&quot;); list1.get(3); //插入操作 System.out.println(&quot;插入操作：&quot;); list1.insert(4, 100); list1.showListInfo(); //删除操作 System.out.println(&quot;删除操作：&quot;); list1.remove(3); list1.showListInfo(); &#125;&#125; 这是一个主函数类，用来测试顺序表的各种操作的实现。 参考:java数据结构与算法之顺序表与链表深入分析 更新时间：2018.4.29]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
        <tag>菜鸟笔记</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所碰到的问题及解决方案]]></title>
    <url>%2F2018%2F04%2F21%2F%E6%89%80%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[关于在博客中添加第三方分享服务的问题 问题描述 关于博客第三方分享服务的实现过程中所出现的问题，在这里详细描述如下 在开启jia this分享服务的过程中所出现的问题：能够成功开启，并且能够在本地服务中正常使用，不过在代码上传到github上之后虽然能够显示出分享片段，不过出现没有按钮，无法成功分享当前页面的问题，点击更多，能够成功分享，但无法分享当前博客主页，只能分享jiathis分享主页。 在开启百度分享服务过程中所出现的问题：完全无法打开分享功能，博客页面无法显示。尝试过多种解决方法，均无法解决问题。 添加第三方sharesdk分享服务中所出现的问题：代码，服务开启都能够成功实现，并且能够在本地预览中实现分享功能，但显示分享失败，代码上传到github之后，出现了同jiathis分享服务相似的问题，分享按钮无效，第三方分享页面无法打开。 解决方案 针对上面问题所尝试的几种方案均无法成功解决问题，在网上也没有查找到相关的问题描述和解决方案 个人观察推测可能是hexo主题配置或者代码上传到github上后出现错误。 该问题尚未解决 更新时间： 2018/4/20日 如何控制博文在主页中显示的字段长度 问题描述 无法控制博文在博客主页推送的字段长短，使得每一篇博文在主页中都是全部显示，对于长篇的博文十分不便于浏览者观看。 解决方法1. 通过&lt;!--more--&gt;标签实现主页显示 2. 通过在头部文件中添加描述标签，具体代码如下： 1234567891011---title: 这是一篇测试博客 #标题date: 2018-04-12 00:54:31categories: 博文的创建和编写 #分类tags: # 标签- Markdown- 博客创建- 技术分享- 菜鸟笔记 #description: 第一篇博文，关于Markdown格式的博文的两种创建方式。 #描述--- 问题已解决 更新时间：2018/4/22日 如何在博文中用灰色字块标记某段博文问题描述有时候我们需要标记博文中某一字段的博文，而markdown语言中却没有支持某字段的标记标签。而引用，代码注释标签，都无法在文本中间插入对某字段进行标记使用。 解决方案思路：由于markdown语言是支持部分HTML语言标签的，所以我们可以尝试使用HTML标签来进行某一字段的标记。 code标签的定义: &lt; code &gt;标签， 用于表示计算机源代码或者其他机器可以阅读的文本内容。软件代码的编写 者习惯了编写代码时的代码格式，那么这个&lt; code &gt;标签就是为软件代码编写者设计的， code标签内的文本将用等宽、类似电传打字机样式的字体（Courier）显示出来。 其使用后的效果是这样的：这是一段使用&lt; code &gt;标签标记的字段 问题已解决 更新时间：2018/4/22日 控制博文主页博文数及NexT主题的一些其他使用问题问题描述：关于NexT主题使用的一些常见问题，和常见配置问题。解决方案 ：这里由于问题比较简单，并且在Next使用文档中都有收录，所以在这里就不一一详细介绍了，这里直接引用* NexT使用文档的相关网页： 常见问题-NexT 使用文档这是一个Next 主题的官方使用文档中的一个常见问题的收录和解决网页。 更新时间:2018/4/23日]]></content>
      <categories>
        <category>问题记录</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
        <tag>菜鸟笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于hexo+github搭建个人博客]]></title>
    <url>%2F2018%2F04%2F20%2F%E5%9F%BA%E4%BA%8Ehexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言 1.github pages服务生成的全是静态文件，访问速度快；2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5.博客内容可以轻松打包、转移、发布到其它平台； hexo、git配置和安装什么是hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装hexo只需要几分钟，但前提是你的确保你的电脑中已经安装了下列应用程序： 下载必须程序 node.js Node.js是一个Javascript运行环境(runtime) Git Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。从上面链接下载git for windows最好挂一个代理，否则下载速度会十分缓慢，你可以参考这个页面,其中收录了存储于百度云的下载地址。 下载之后你可以在你想要创建博客的位置新建一个文件夹，进行node.js和git的安装，打开安装包，按顺序安装即可。安装完成后可以打开cmd命令行检查是否安装完成： hexo安装 打开git命令行输入以下代码安装hexo1$ npm install -g hexo-cli 建站安装好hexo后执行下列操作来生成所需要的文件 初始化 在你的电脑选取一个你想要存放这个网页的代码的文件夹，然后在里面新建一个hexo文件夹。 在git命令行中输入：12$ cd /d/网页设计/hexo$ hexo init 下载完成后，会在对应的hexo文件中自动生成对应文件。 生成文件和启用预览服务在git命令行中输入以下命令：12$ hexo g # 生成$ hexo s # 启动服务 会在public文件中生成相关的HTML文件。 用来启用本地预览服务，启用后就可以通过http://localhost:4000/来预览博客内容。如果一切顺利，访问以上预览链接应当出现这样的一个默认博客主页。至这一步，一个基于hexo的blog就搭建完成了。 如何将博客部署到github在生成博客初始页面后，我们的博客还不算完成，因为我们只能看到的知识hexo提供的一个本地预览网页，别人是看不到的，那么如何才能让别人也可以访问的到我们的博客呢，那就需要我们把博客部署到网上了，这里，我选择的是github。 注册github账户和新建仓库首先，我们需要在github上有一个账户。 github官网 点击链接进入github官网注册。注册好之后点击sign in登录github。 点击new repository新建一个名为你的用户名.github.io的仓库。如我的用户名是gemuxiaoshe，那么我就需要新建一个gemuxiaoshe.github.io的仓库，这样你之后的网站地址就可以直接使用https://gemuxiaoshe.github.io/访问仓库了。 配置SSH key 为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。 我们在github命令行中输入以下命令来检测本机已存在的ssh密匙 1$ cd ~/. ssh #检查本机已存在的ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 在github命令行中输入以上命令，然后连续三次回车。最后会在你的用户目录下生成一个id_rsa.pub文件,找到并打开它（可以直接使用记事本打开），复制里面的全部内容，然后打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 输入以下命令测试SSH key是否配置成功1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 最后我们还需要配置：12$ git config --global user.name &quot;liuxianan&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 部署代码到github上在配置还SSH key之后，我们上传代码就很容易了 这时候我们还不能直接使用hexo d 上传代码，因为我们还有_config.yml没有配置。打开_config.yml站点配置文件,目录为：D:\网页设计\hexo_config.yml找到deploy关键词进行如下配置： 1234deploy: type: git repository: git@github.com:liuxianan/liuxianan.github.io.git #你的用户名和你新建的仓库名 branch: master 配置成功之后，我们可以尝试使用hexo d 来上传我们的代码，但这个时候应当是无法上传成功的。它会出现以下内容：1Deployer not found: git 表示它没有发现git 这是因为我们还需要安装一个插件：1npm install hexo-deployer-git --save 安装成功后我们就可以开始上传我们的代码了首先我们用hexo g来生成一下文件 1$ hexo g 再输入以下命令上传代码到github上：1$ hexo d 上传成功！之后你可以登录你的github主页查看代码是否上传成功。并且可以直接使用你之前设置好的仓库地址https://gemuxiaoshe.github.io/登录到你的博客主页了。 博客的进阶学习主题的更改和优化以及博客的创建和编写至此，博客搭建才算正式完成，你的博客将可以被访问到。不过到目前我们只是刚刚创建了一个默认的博客主页，和一篇默认的博客，且这个默认主页当然是不可能让我们满意的，并且其功能也肯定会有所不足。那么我们首先，我们还需要进行的最基本的工作就是学习如何修改和优化我们的主题，并且学习博客的创建和编写。 关于博客的创建和编写可以参考我的另两篇博文 这是一篇测试博客主要介绍了博文的两种创建方式。 markdown语言中基本标签的使用主要介绍了博文编写所较常使用的markdown标记语言的基本使用方法 关于博客主题的修改和优化可以参考下面的网站，在这里就不进行详细过程的介绍了 NexT 使用文档 NexT 一款基于hexo的主题，NexT 使用文档详细的介绍了基于hexo的主题NexT的使用方法，和NexT主题的配置方法，以及各种第三方服务的配置方法，同时也包括一些基本的站点文件配置。其中配置方式是适用于多种主题的。 hexo的next主题个性化教程:打造炫酷网站一个简书上的Next主题的个性化配置教程，其中还包括一些Next使用文档所没有的进阶配置，比较详细的介绍了主题的各种个性化配置。。 关于分享功能实现的补充由于我使用的百度分享和jiathis分享均出现了问题，并且并没有找到解决的办法，于是使用了另外一个第三方分享服务sharesdk。 具体实现方法请点击下面链接为Hexo NexT主题添加ShareSDK的分享 关于分享功能的的尝试结果 在最终尝试了各种分享服务后还是发现我的分享功能还是没能在基于github上实现，在网上也没有找到相关的问题描述和解决方式。非常遗憾只能暂时放弃分享功能的使用。在之后的过程中再来补充。 参考 hexo使用文档hexo的官方使用文档，十分详细的总结归纳了hexo的各种使用方法。 小茗同学的博客园一个比较详细的hexo+github搭建博客的教程 hexo的next主题个性化教程:打造炫酷网站一个next主题修改优化教程 NexT 使用文档next主题的官方使用文档，十分详细的介绍了next主题的各种使用方法]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>技术分享</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简记个人博客搭建历程]]></title>
    <url>%2F2018%2F04%2F20%2F%E7%AE%80%E8%AE%B0%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8E%86%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[搭建个人博客的起因 由于一直是计算机专业，所以在很久之前，便想搭建一个属于自己的个人博客。但苦于一直没有时间，也没有接触过这方面的东西等原因，一直没能实现。直到我们开了HTML课程，正好涉及到网页设计这方面，而课程的最终任务，就是设计一个独立网页。这时，我便恰好使用这个机会开始了个人博客搭建的探索。 基于wordPress的博客尝试 在博客搭建的初期，经过一系列的搜索和查找相关资料后，我首先选择的是wordPress提供的一个博客服务，其原因有三点： 它是一个评价较好的比较大众的博客平台 它也提供一个免费的博客服务和域名支持，可以不用任何花费便可被访问到 它的搭建过程可以是极简单的，同时也支持更自由的博客创建方式 但在使用不久我就放弃了使用wordpress的博客服务，主要出于其创建过于简单，只需要注册账户，选好主题就可以快速创建属于自己的博客，且其免费的博客服务中众多的功能都受到了限制，需要付费使用，无法涉及到更基础的网页设计知识。对我的帮助较小。 基于github+HTML的博客尝试 放弃使用wordpress的博客服务之后，已经对博客搭建这方面有了一定的了解了，并且在HTML的课程中也开始了网页设计的尝试。在这个过程中，通过查找资料，找到了一个比较好的博客搭建方式，那就是github代码寄存库。github是一个代码保存网站，并且它是免费给予用户500兆空间，在github中它会给我们自动生成一个静态页面，并且它是可以被访问的，也就是说我们只需要把我们自己编写好的网页代码上传到github上，我们便可以通过其自动生成的静态网页访问到我们的主页了。通过这种方式，我开始了第二次博客搭建的历程。github所具备的优点： 完全免费 开放性和极度的自由性，github是一个开放的代码交流和分享的平台。并且其代码完全可以由自己编写 具有一定深度，适合专业方面的人员使用，你可以在github上fork他人代码学习和研究，也可以自己编写代码，上传分享。适合学习。 在一段时间的摸索中，我成功的创建并上传了我的第二个博客，并可以被访问，代码基于HTML，是在学习HTML的过程中一点一点摸索着设计出来的。不过由于基础知识的严重缺乏，所编写的博客十分简陋，基本不具备可用性，和阅读性。我便暂时停止了第二个博客的编写，在之后的学习过程中，再来更新设计这个网页。目前暂时放下。 之后便开始尝试直接在其他的HTML博客主题上摸改博客，搭建自己的第三个博客，这个过程同样是漫长而枯燥的，不过最终的还是取得了不错的效果，并且在摸改过程中，对于HTML，css，都有了一定的了解，不再是一眼黑了。 但在不久后，我便也暂时放弃了第三个博客的更新和维护，其主要原因是已经达到了一个瓶颈，无法再短时间内做出功能更加强大的改变了，而博客功能又过于简单，无法满足一个完善博客的基本要求。我便暂时放弃了它的设计和维护，只做了一些简单的内容更新。 详细创建过程请看： 基于hexo+github的博客尝试 由于数据结构课程，开始接触到了hexo博客创建的方式。hexo是一个快速，简洁且高效的博客框架，并且其功能十分齐全，支持markdown语言编辑博文。同时其也是一个开放性的平台，拥有着众多主题，你可以根据这个框架摸改他人博客模板，也可以自己依据hexo来快速编写自己的博客框架。同时它可以一键部署到各平台，网站。于是，我便开始了基于github上的hexo博客搭建过程。这个过程无疑是搭建博客以来最为繁琐的一次，因为这是一种全新的博客搭建方式。不过好在有hexo的使用文档可以帮助我们搭建博客。在经历一段时间的摸索和各种失败，和各种问题后。我也终于搭建好了这第四个个人博客，使用next主题，其主题文件配置，及站点文件配置着实花费了不少时间。但最终总算成功完成博客的搭建，还算是小有收获，在这个过程中最主要的应该就是了解了markdown语言的使用了。 详细搭建过程请看博文： 基于hexo+github搭建个人博客这是我的一个博客搭建笔记，比较详细的介绍了基于hexo+github的博客搭建过程。 本博客即是基于hexo+github搭建的第四个博客，同时本篇博文也是使用markdown语言书写。 最后附上各阶段博客地址 个人博客这是基于wordpress创建的第一个博客，基本没怎么使用 葛木小舍先生的小世界这是基于HTML的个人编写的静态个人网页，之后将会持续更新 葛木小舍先生的个人博客这是基于HTML主题的模改个人博客 葛木小舍先生的博客这是目前在使用的个人博客，基于hexo搭建。 以上博客代码均存放在github，网址使用的是github默认位置]]></content>
      <categories>
        <category>心得总结</category>
      </categories>
      <tags>
        <tag>博文创建</tag>
        <tag>个人心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是一篇测试博文]]></title>
    <url>%2F2018%2F04%2F12%2F%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[这是葛木小舍先生的第一篇博文 I love three things:the sun ,the moon and you.the sun is for the day ,the moon is for the nightand you forever.我爱三样东西，太阳，月亮和你。太阳留给白天，月亮留给夜晚，而你，是永远。 关于新建博文的两种方法： 通过git命令窗口新建博文 这一篇博文是直接由git命令窗口创建1hexo new &apos;my-first-blog&apos; 通过命令行创建.md格式的Markdown文件，之后找到其所在的位置。打开它（Markdown文档是纯文本文档，可以用任何文本编辑器打开编辑）进行编辑。 直接新建.md格式文档放到博客目录下新建博文我们可以直接找到博文存放的位置，直接在里面新建.md文件创建 这里需要注意的是：在文件的开始，一定的需要加上title等必要元素，这样它才能在博客中显示出来。1234567---title: 这是一篇测试博客 #文章页面上的显示名称，一般是中文date: 2018-04-11 17:10:10 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面--- 参考： 写作|hexo这是一个关于hexo的使用的官方网站。 小茗同学的博客园这是我参考的一个基于hexo+github的一个比较详细的博客搭建教程]]></content>
      <categories>
        <category>博文的创建和编写</category>
      </categories>
      <tags>
        <tag>博客创建</tag>
        <tag>技术分享</tag>
        <tag>菜鸟笔记</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
